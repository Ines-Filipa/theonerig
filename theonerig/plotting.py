# AUTOGENERATED! DO NOT EDIT! File to edit: 04_plotting.ipynb (unless otherwise specified).

__all__ = ['DEFAULT_COLORS', 'plot_2d_sta', 'plot_cross_correlation', 'plot_2d_fit', 'plot_ds_wheel',
           'plot_dark_white_response', 'plot_t_sta', 'plot_chirp', 'plot_spike_template', 'plot_autocorrelogram',
           'plot_spike_amplitudes', 'plot_stim_epochs_to_spikes', 'plot_recap_vivo_ephy']

# Cell
import matplotlib.pyplot as plt
from matplotlib import gridspec
import seaborn as sns
import pandas as pd
import numpy as np
from cmath import *

from .core import *
from .processing import *
from .utils import *
from .modelling import *

DEFAULT_COLORS = plt.rcParams['axes.prop_cycle'].by_key()['color']

# Cell
def plot_2d_sta(sta, grid=None):
    sta = np.array(sta)
    if len(sta.shape) == 2:
        sta = [sta]
    if grid is None:
#         fig = plt.figure(figsize=(20,4+len(sta)//8*2))
        grid = gridspec.GridSpec(len(sta)//8 + 1, 8)
        for i, frame in enumerate(sta):
            ax = plt.subplot(grid[i//8, i%8])
            ax.imshow(frame, cmap='gray',vmin=-1, vmax=1)
    else:
        grid_x, grid_y = grid.get_geometry()
        for i in range(grid_x):
            for j in range(grid_y):
                ax = plt.subplot(grid[i*grid_x+j])#fig.add_subplot(grid[i])
                ax.imshow(sta[i*grid_x+j], cmap='gray',vmin=-1, vmax=1)
                if i!=grid_x-1:
                    ax.set_xticks([])
                if j != 0:
                    ax.set_yticks([])

# Cell
def plot_cross_correlation(correlation_array, threshold=.1  ,two_sided=True):
    n_cell = correlation_array.shape[0]
    _min,_max = np.min(correlation_array), np.max(correlation_array)
    thresh = (_max-_min) * threshold
    for i in range(n_cell):
        for j in range(i, n_cell):
            c = "#1f77b4"
            if np.max(correlation_array[i,j])-np.min(correlation_array[i,j]) > thresh:
                c = "red"
            for k in range(2 if two_sided else 1):
                if k==0:
                    ax = fig.add_subplot(n_cell,n_cell,i*n_cell+j+1, ylim=(_min,_max), label=str(i*n_cell+j+1))
                else:
                    ax = fig.add_subplot(n_cell,n_cell,j*n_cell+i+1, ylim=(_min,_max), label="b"+str(i*n_cell+j+1))
                plt.plot(correlation_array[i,j], c=c)
                plt.axis('off')
                if i == 0 and k==0:
                    ax.set_title(str(j))
                elif i == 0 and k==1:
                    ax.set_title(str(j), pad =-50, loc="left")
                elif i == j:
                    ax.set_title(str(j), pad =-50, loc="center")

# Cell
def plot_2d_fit(sta, param_d):
    plt.subplot(1,2,1)
    plt.imshow(sta, vmin=-1,vmax=1, cmap="gray")
    plt.subplot(1,2,2)

    plt.imshow(img_2d_fit(sta.shape, param_d, f=sum_of_2D_gaussian), vmin=-1,vmax=1, cmap="gray")

# Cell
def plot_ds_wheel(ax, ds_dict, cell_idx):
    key_0 = list(ds_dict.keys())[0]

    n_angle = ds_dict[key_0][0].shape[1]
    x = np.linspace(0, (n_angle-1)/4*np.pi, num=n_angle)

    linestyle = [":", "--"]
    for j, (key, data) in enumerate(ds_dict.items()):
        spike_counts = data[0][cell_idx,:]
        dir_pref = data[1][cell_idx]
        mod, phase = polar(dir_pref)


        ax.plot(np.concatenate((x, x[0:1])), np.concatenate((spike_counts, spike_counts[0:1])),
                linestyle=linestyle[j//2], c=DEFAULT_COLORS[j%2], label=key+" "+str(round(mod,3)))
        ax.legend(loc=(-.1,-.16))

#             plt.arrow(0, 0, phase, max_spike/2, width=.04, length_includes_head=True, head_length=30,
#                      shape="left")

# Cell
def plot_dark_white_response(ax, spike_bins):
    """spike_bins must be of shape (2, n_cell, trial_len), the dark beeing at idx 0 and white at idx 1
    of the first dimension."""
    for i in range(spike_bins.shape[1]):
        ax.plot(spike_bins[0,i], label="dark", c="#000000")
        ax.plot(spike_bins[1,i], label="white", c="#8F8F8F")
        ax.set_title('Cell '+str(i))
        ax.legend()

# Cell
def plot_t_sta(ax, sta):
    ax.plot(np.linspace(0,len(sta)/60,len(sta))[::-1]*(-1),sta)
    ax.set_ylim(-1,1)

# Cell
def plot_chirp(ax, stim_inten, spike_bins, n_repeats=10, smooth=True):
    trace = spike_bins.reshape(n_repeats,-1)
    len_    = trace.shape[1]

    df = pd.DataFrame(columns=["timepoint","repeat","signal"])
    for i, repeat_am in enumerate(trace):
        if smooth:
            repeat_am = np.convolve([.333]*3, repeat_am, mode="same")
        repeat_df = pd.DataFrame(list(zip(np.linspace(0,len_/60,len_),
                                          [str(i)]*len_,
                                          repeat_am)), columns=["timepoint","repeat","signal"])
        df = df.append(repeat_df, ignore_index=True)
    g = sns.relplot(x="timepoint", y="signal",
                kind="line", data=df, ax=ax)
#         trace = np.mean(trace, axis=0)
#         if smooth:
#             trace = np.convolve([.2]*3, trace, mode="same")
#         plt.plot(np.linspace(0,len_/60,len_), trace)

    min_val, max_val = ax.get_ylim()
    ax.set_ylim(min_val , (max_val-min_val)*6/5)
    ax.set(xlabel='', ylabel='')
    ax.imshow([stim_inten.reshape(n_repeats,-1)[0]], aspect='auto', cmap="gray", extent=(0,len_/60,(max_val-min_val)*6/5,max_val))

# Cell
def plot_spike_template(ax, cluster_composition, templates, shanks_idx, channel_positions):
    tmp = cluster_composition[0]
    n_points = 30
    mask_trace = np.arange(templates.shape[1]//2-10,
                           templates.shape[1]//2+(n_points-10))

    template_pos = np.where(np.abs(templates[cluster_composition[0]])
                            == np.max(np.abs(templates[cluster_composition[0]])))[1][0]
    template_shank = np.where(shanks_idx==template_pos)[0][0]
    shank_templates = templates[:,:,shanks_idx[template_shank]]

    min_x = np.min(channel_positions[shanks_idx[template_shank]][:,0])
    for i, pos in enumerate(channel_positions[shanks_idx[template_shank]]):
        for j, cell in enumerate(cluster_composition):
            color = DEFAULT_COLORS[j]
            ax.plot(np.arange(n_points)+pos[0]-min_x, shank_templates[cell,mask_trace,i]*4+pos[1], c=color)
    ax.set_title("Shank "+str(template_shank+1))

def plot_autocorrelogram(ax, cluster, spike_times, spike_clusters, bin_ms=.001, sampling_rate=30000, tails=30):
    cluster_mask = spike_clusters==cluster
    cluster_times = spike_times[cluster_mask]
    hist = np.histogram(cluster_times, bins=np.linspace(0,cluster_times[-1], cluster_times[-1]/(bin_ms*sampling_rate)))[0]
    hist_tails = np.concatenate(([0]*tails, hist, [0]*tails))
    corr = np.correlate(hist_tails, hist, mode="valid")
    corr[tails]=0

    ax.bar(np.linspace(-tails*bin_ms*1000,tails*bin_ms*1000,tails*2+1), corr, width=bin_ms*1000)
    ax.set_title("Autocorrelogram, bin="+str(bin_ms*1000)+"ms")

def plot_spike_amplitudes(ax, cluster, spike_templates, spike_clusters, spike_times, amplitudes):
    mask_cluster = spike_clusters==cluster
    for templ in np.unique(spike_templates[mask_cluster]):
        mask_template = spike_templates==templ
        plt.scatter(spike_times[mask_template], amplitudes[mask_template], s=.2)

    ax.set_xticks([])
    ax.set_title("Spike amplitudes")

def plot_stim_epochs_to_spikes(ax, reM, y_pos):
    pos_text_cursor = 1
    seq = reM._sequences[0]
    stim_names = seq.get_names_group("stim")
    for stim_name in stim_names:
        dc = seq._data_dict[stim_name][0]
        len_dc = seq["main_tp"][dc.idx+len(dc)]-seq["main_tp"][dc.idx]
        start_dc = seq["main_tp"][dc.idx]
        ax.barh(y_pos, len_dc, left=start_dc, height=.1)
        ax.text(start_dc, y_pos+(.1*pos_text_cursor), stim_name, fontdict={"size":5})
        pos_text_cursor*=-1


# Cell
def plot_recap_vivo_ephy(title_dict, reM, phy_dict, cluster_ids, cell_db_ids=None,
                         checkerboard=None, fullfield_fl=None, chirp_am=None,
                         chirp_fm=None, moving_gratings=None, fl_bars=None):
    """Plot the recapitulating form of in vivo electrophy records
    title_dict -> A dictionnary containing the str info for the title: keys(condition, date, record_name, record_id)
    reM -> The record master object of the record
    phy_dict -> A dictionnary containing the matrix obtained from phy (see utils.phy_results_dict())
    cluster_ids -> A list of the cluster id used by phy corresponding to the good cells analysed
    cell_db_ids -> A list of the database ids of the cells corresponding to cluster_ids
    checkerboard -> A matrix of STA of cells to the checkerboard stimulus of shape (n_cell, 16, height, width)
    fullfield_fl -> A matrix of STA of cells to the fullfield_flicker stimulus of shape (n_cell, 16)
    chirp_am -> A tuple of the chirp_am obtained from a pipe, where [0] is the stimulus and [1] the cells response
    chirp_fm -> Same as chirp_am but for a chirp_fm stimulus
    moving_gratings -> The dict of response obtained from utils.group_direction_response
    fl_bars -> A matrix of STA of cells to the flickering_bars stimulus of shape (n_cell, 16, height, width)
    """
    SMALL_SIZE = 14#8
    MEDIUM_SIZE = 18#10
    BIGGER_SIZE = 24#12
    plt.rc('font', size=SMALL_SIZE)          # controls default text sizes
    plt.rc('axes', titlesize=SMALL_SIZE)     # fontsize of the axes title
    plt.rc('axes', labelsize=MEDIUM_SIZE)    # fontsize of the x and y labels
    plt.rc('xtick', labelsize=SMALL_SIZE)    # fontsize of the tick labels
    plt.rc('ytick', labelsize=SMALL_SIZE)    # fontsize of the tick labels
    plt.rc('legend', fontsize=SMALL_SIZE)    # legend fontsize
    plt.rc('figure', titlesize=BIGGER_SIZE)  # fontsize of the figure title

    sns.set_context("notebook", rc={"font.size":SMALL_SIZE,
                                    "axes.titlesize":SMALL_SIZE,
                                    "axes.labelsize":MEDIUM_SIZE,
                                    "xtick.labelsize":SMALL_SIZE,
                                    "ytick.labelsize":SMALL_SIZE,
                                    "legend.fontsize":SMALL_SIZE,
                                    "figure.titlesize":BIGGER_SIZE})

    shanks_idx = buszaki_shank_channels(phy_dict["channel_positions"])
    cond = title_dict["condition"]
    date = title_dict["date"]
    record_name = title_dict["record_name"]
    record_id = title_dict["record_id"]

    if cell_db_ids is None:
        cell_db_ids = [-1]*len(cluster_ids)

    for cluster, cell_id in zip(cluster_ids, cell_db_ids):
        reM_cell_idx = np.where(cluster==cluster_ids)[0][0]

        fig = plt.figure(figsize=(8.267717*2,11.69291*2)) #A4 values in inches(damn) *2
        suptitle = " - ".join([cond, date, record_name+" n°"+str(record_id),
                               "Cluster n°"+str(cluster), "Cell id n°"+str(cell_id)])
        plt.suptitle(suptitle)

        mask_cluster = phy_dict["spike_clusters"]==cluster
        cluster_composition = np.unique(phy_dict["spike_templates"][mask_cluster])

        gs = gridspec.GridSpec(28, 20, left=0.05, right=.95, top=.92, bottom=.05, wspace=0.00, hspace=0.00)

        #Template on electrodes
        cell_loc_ax = fig.add_subplot(gs[0:4,0:2])
        plot_spike_template(cell_loc_ax, cluster_composition, phy_dict["templates"], shanks_idx, phy_dict["channel_positions"])

        #Autocorrelogram
        autocorr_ax = fig.add_subplot(gs[0:4,3:7])
        plot_autocorrelogram(autocorr_ax, cluster, phy_dict["spike_times"], phy_dict["spike_clusters"],
                             bin_ms=.001, sampling_rate=30000, tails=30)

        #Spike amplitude across time
        sp_amp_ax = fig.add_subplot(gs[0:4,8:])
        plot_spike_amplitudes(sp_amp_ax, cluster, phy_dict["spike_templates"], phy_dict["spike_clusters"],
                              phy_dict["spike_times"], phy_dict["amplitudes"])
        plot_stim_epochs_to_spikes(sp_amp_ax, reM, y_pos=0.6)

        #Checkerboard STA
        inner_grid = gridspec.GridSpecFromSubplotSpec(4, 4,
                    subplot_spec=gs[5:12,0:12], wspace=.09, hspace=.13)
        plot_2d_sta(checkerboard[reM_cell_idx], grid=inner_grid)

        #Fullfield flickering STA
        sp_amp_ax = fig.add_subplot(gs[5:12,13:])
        plot_t_sta(sp_amp_ax, fullfield_fl[reM_cell_idx])
        sp_amp_ax.set_title("Fullfield_flickering")

        #Chirp_FM
        chirpfm_ax = fig.add_subplot(gs[13:16,:])
        plot_chirp(chirpfm_ax, chirp_fm[0], chirp_fm[1][:,reM_cell_idx], n_repeats=10)
        chirpfm_ax.set_title("Chirp FM")

        #Chirp_AM
        chirpam_ax = fig.add_subplot(gs[17:20,:])
        plot_chirp(chirpam_ax, chirp_am[0], chirp_am[1][:,reM_cell_idx], n_repeats=10)
        chirpam_ax.set_title("Chirp AM")

        #Flickering bars
        nonlin_ax = fig.add_subplot(gs[21:,:12])
        nonlin_ax.set_title("Flickering_bars")

        #Moving gratings
        ds_ax = fig.add_subplot(gs[21:,13:], projection="polar")
        plot_ds_wheel(ds_ax, moving_gratings, cell_idx=reM_cell_idx)

    plt.rcdefaults()