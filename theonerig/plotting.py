#AUTOGENERATED! DO NOT EDIT! File to edit: dev/04_plotting.ipynb (unless otherwise specified).

__all__ = ['plot_2d_sta', 'plot_cross_correlation', 'plot_2d_fit', 'plot_ds_wheel', 'plot_dark_white_response',
           'plot_t_sta', 'plot_chirp']

#Cell
import matplotlib.pyplot as plt
from matplotlib import gridspec
import numpy as np
from cmath import *

from .core import *
from .processing import *
from .utils import *
from .modelling import *

#Cell
def plot_2d_sta(sta, grid=None):
    sta = np.array(sta)
    if len(sta.shape) == 2:
        sta = [sta]
    if grid is None:
#         fig = plt.figure(figsize=(20,4+len(sta)//8*2))
        grid = gridspec.GridSpec(len(sta)//8 + 1, 8)
        for i, frame in enumerate(sta):
            ax = plt.subplot(grid[i//8, i%8])
            ax.imshow(frame, cmap='gray',vmin=-1, vmax=1)
    else:
        grid_x, grid_y = grid.get_geometry()
        for i in range(grid_x):
            for j in range(grid_y):
                ax = plt.subplot(grid[i*grid_x+j])#fig.add_subplot(grid[i])
                ax.imshow(sta[i*grid_x+j], cmap='gray',vmin=-1, vmax=1)
                if i!=grid_x-1:
                    ax.set_xticks([])
                if j != 0:
                    ax.set_yticks([])

#Cell
def plot_cross_correlation(correlation_array, threshold=.1  ,two_sided=True):
    n_cell = correlation_array.shape[0]
    _min,_max = np.min(correlation_array), np.max(correlation_array)
    thresh = (_max-_min) * threshold
    for i in range(n_cell):
        for j in range(i, n_cell):
            c = "#1f77b4"
            if np.max(correlation_array[i,j])-np.min(correlation_array[i,j]) > thresh:
                c = "red"
            for k in range(2 if two_sided else 1):
                if k==0:
                    ax = fig.add_subplot(n_cell,n_cell,i*n_cell+j+1, ylim=(_min,_max), label=str(i*n_cell+j+1))
                else:
                    ax = fig.add_subplot(n_cell,n_cell,j*n_cell+i+1, ylim=(_min,_max), label="b"+str(i*n_cell+j+1))
                plt.plot(correlation_array[i,j], c=c)
                plt.axis('off')
                if i == 0 and k==0:
                    ax.set_title(str(j))
                elif i == 0 and k==1:
                    ax.set_title(str(j), pad =-50, loc="left")
                elif i == j:
                    ax.set_title(str(j), pad =-50, loc="center")

#Cell
def plot_2d_fit(sta, param_d):
    plt.subplot(1,2,1)
    plt.imshow(sta, vmin=-1,vmax=1, cmap="gray")
    plt.subplot(1,2,2)

    plt.imshow(img_2d_fit(sta.shape, param_d, f=sum_of_2D_gaussian), vmin=-1,vmax=1, cmap="gray")

#Cell
def plot_ds_wheel(ds_dict, cell_idx):
    key_0 = list(ds_dict.keys())[0]

    n_angle = ds_dict[key_0][0].shape[1]
    x = np.linspace(0, (n_angle-1)/4*np.pi, num=n_angle)

    linestyle = [":", "--"]
    def_colors = plt.rcParams['axes.prop_cycle'].by_key()['color']
    for j, (key, data) in enumerate(ds_dict.items()):
        spike_counts = data[0][cell_idx,:]
        dir_pref = data[1][cell_idx]
        mod, phase = polar(dir_pref)


        plt.plot(np.concatenate((x, x[0:1])), np.concatenate((spike_counts, spike_counts[0:1])),
                linestyle=linestyle[j//2], c=def_colors[j%2], label=key+" "+str(round(mod,3)))
        plt.legend(loc=(-.1,-.16))

#             plt.arrow(0, 0, phase, max_spike/2, width=.04, length_includes_head=True, head_length=30,
#                      shape="left")

#Cell
def plot_dark_white_response(spike_bins):
    """spike_bins must be of shape (2, n_cell, trial_len), the dark beeing at idx 0 and white at idx 1
    of the first dimension."""
    for i in range(spike_bins.shape[1]):
        plt.plot(spike_bins[0,i], label="dark", c="#000000")
        plt.plot(spike_bins[1,i], label="white", c="#8F8F8F")
        plt.title('Cell '+str(i))
        plt.legend()

#Cell
def plot_t_sta(sta):
    plt.plot(np.linspace(0,len(sta)/60,len(sta))[::-1]*(-1),sta)
    plt.ylim(-1,1)

#Cell
def plot_chirp(stim_inten, spike_bins, n_repeats=10):
    mean_trace = np.mean(spike_bins.reshape(n_repeats,-1), axis=0)
    mean_trace_smooth = np.convolve([.2]*3, mean_trace)
    max_val = np.max(mean_trace_smooth)
    len_    = len(mean_trace_smooth)
    plt.plot(np.linspace(0,len_/60,len_), mean_trace_smooth)
    plt.ylim(0, max_val*6/5)
    plt.imshow([stim_inten.reshape(n_repeats,-1)[0]], aspect='auto', cmap="gray", extent=(0,len_/60,max_val*6/5,max_val))